---
title: 篡改数据
description: 篡改数据
ms.assetid: 277395b9-b770-45b4-8f4c-cad8b684ca44
keywords:
- 威胁模型 WDK 文件系统，数据篡改
- 安全威胁模型 WDK 文件系统，数据篡改
- 数据篡改 WDK 文件系统
- 篡改数据 WDK 文件系统
- 缓冲 WDK 文件系统
- IOCTLs WDK 文件系统
ms.date: 04/20/2017
ms.localizationpriority: medium
ms.openlocfilehash: d697d761875b1ba2f2dc991fe71aaf94942196f0
ms.sourcegitcommit: 7b9c3ba12b05bbf78275395bbe3a287d2c31bcf4
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/28/2020
ms.locfileid: "89063222"
---
# <a name="tampering-with-data"></a>篡改数据


## <span id="ddk_tampering_with_data_if"></span><span id="DDK_TAMPERING_WITH_DATA_IF"></span>


数据篡改是对驱动程序的威胁，但对文件系统和文件系统筛选器驱动程序的威胁非常严重。 对于所有驱动程序，在用户模式组件和内核模式组件之间共享的任何控制结构在由内核模式组件使用时可能会由用户模式组件修改。 文件系统和筛选器驱动程序特别容易受到此类攻击，因为它们对方法的 \_ 数据传输类型的依赖性很强，这两种传输类型通过其虚拟地址直接访问用户缓冲区。 Fast i/o 还直接访问原始用户模式缓冲区。 此处的风险在于，驱动程序可能在应用程序修改数据时使用此数据。 通常，驱动程序会通过验证数据来尝试防止这种情况。 但是，仅当数据在验证后无法更改时，数据验证才起作用。

对于文件系统和文件系统筛选器驱动程序，有很多 IOCTL 和 FSCTL 操作，用于在用户模式应用程序和各种内核模式驱动程序之间传输信息。 此外，此类驱动程序具有专用的 IOCTL 和 FSCTL 操作，这些操作还会在用户模式服务及其内核模式驱动程序之间传输控制和数据信息。

此设计模型中的固有假设只有驱动程序的服务或应用程序才能利用其接口。 此类设计和实现存在风险，原因如下：

-   恶意应用程序可能会将有效的缓冲区发送到驱动程序，然后修改数据以尝试探测并找出驱动程序的缺点。

-   控制应用程序内的失败可能导致控件缓冲区的数据内容无效。 例如，如果异常更改了控制流并导致重复使用堆栈区域，则基于堆栈的控件区域可能会无效。

防范此类问题需要在实现方面警惕常量。 在验证之前，缓冲区必须位于非易失性内存 (仅限内核或只读内存) 。 如果缓冲区包含对任何其他缓冲区或控制结构的引用，则在对其进行验证之前，它们必须位于非易失性内存中。

开发人员还应注意使用 **FastIoDeviceControl** 调度的 IOCTL 将在原始用户缓冲区中传递数据。 因此，为 IOCTLs 实现快速 i/o 版本的驱动程序应采取适当的措施来防止出现问题。

请注意，单独验证数据是不够的。 例如，对 [**ProbeForWrite**](/windows-hardware/drivers/ddi/wdm/nf-wdm-probeforwrite) 的成功调用可能指示缓冲区有效，但应用程序地址空间中的后续更改可能会导致该状态更改。 例如，应用程序可能会在实际使用缓冲区之前终止。 因此，该驱动程序必须防止应用程序的地址空间中的任何更改。 通常，这是使用结构化异常处理的，使用** \_ \_ try** ** \_ \_ ，而不**是直接访问用户缓冲区地址的任何代码。

 

