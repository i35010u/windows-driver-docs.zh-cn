---
title: 原子总线操作
description: 若要使用已连接到 SPB 的外围设备的某些硬件功能，SPB 控制器的客户端 (即，外设驱动程序) 可能需要执行与设备之间的数据传输序列作为原子总线操作。
ms.assetid: F8CD670F-C817-40BF-AF4B-5F3839E46EFB
ms.date: 04/20/2017
ms.localizationpriority: medium
ms.openlocfilehash: 0220a3f54bd25c8de8d284c2ce313df5defeae37
ms.sourcegitcommit: c766ab74e32eb44795cbbd1a4f352d3a6a9adc14
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/02/2020
ms.locfileid: "89389566"
---
# <a name="atomic-bus-operations"></a>原子总线操作


若要使用已连接到 SPB 的外围设备的某些硬件功能，SPB 控制器的客户端 (即，外设驱动程序) 可能需要执行与设备之间的数据传输序列作为原子总线操作。 传输序列是原子的，因为任何其他客户端都不能在总线上的设备之间传输数据，直到序列结束。

客户端执行传输序列作为原子总线操作的典型方法是向目标设备发送 [**IOCTL \_ SPB \_ 执行 \_ 序列**](https://msdn.microsoft.com/library/windows/hardware/hh450857) 请求。 在此请求中，客户端将序列指定为简单的读取和写入传输的列表。 列表可以是任意长度。 读取和写入按其列出的顺序执行，每次读取或写入都可以传输任意字节数。 大多数 SPB 控制器都支持 **IOCTL \_ SPB \_ 执行 \_ 序列** 请求。

## <a name="spb-controller-locks"></a>SPB 控制器锁


执行原子传输序列的常见方法是使用 SPB 控制器锁定。 客户端发送 [**ioctl \_ spb \_ 锁 \_ 控制器**](https://msdn.microsoft.com/library/windows/hardware/hh450858) 请求以获取锁，并向 [**ioctl \_ spb 解除锁定 \_ \_ 控制器**](https://msdn.microsoft.com/library/windows/hardware/hh450859) 请求以释放锁。 当客户端持有控制器锁时，将客户端发送到设备的任何简单读和写操作序列 ([**irp \_ mj \_ 读取**](../kernel/irp-mj-read.md) 和 [**IRP \_ mj \_ 写入**](../kernel/irp-mj-write.md)) 请求将作为总线上的原子操作执行。

大多数与 SPB 连接的外围设备不需要控制器锁定，大多数 SPB 控制器驱动程序也不支持这些锁。 然而，一些客户端可能需要使用控制器锁来访问具有异常功能的设备。

例如，设备可能实现仅可通过在总线上为原子的读修改写入操作来访问的设备功能。 若要执行此类操作，客户端按) 显示的顺序发送以下四个 i/o 请求 (：

1.  **IOCTL \_SPB \_ 锁 \_ 控制器** –获取控制器锁。
2.  **IRP \_MJ \_ read** –从目标设备读取数据块。
3.  **IRP \_MJ \_ 写入** –将修改后的数据写入到设备。
4.  **IOCTL \_SPB \_ 解锁 \_ 控制器** -释放控制器锁。

上述列表中的读取操作完成后，客户端将解释从设备读取的数据，并在将数据写回设备之前修改数据。

但是，很少连接了 SPB 的设备具有需要控制器锁定的功能。 对于需要原子总线操作的大多数设备， [**IOCTL \_ SPB \_ 执行 \_ 序列**](https://msdn.microsoft.com/library/windows/hardware/hh450857) 请求都已足够。

不要将 SPB 控制器锁与 SPB 连接锁混淆。 在两个客户端共享对同一 SPB 连接的外围设备的访问的异常情况下，客户端可以使用连接锁来暂时获得对设备的独占访问权限。 有关详细信息，请参阅 [SPB 连接锁](./spb-connection-locks.md)。

## <a name="hardware-bus-signals"></a>硬件总线信号


若要处理 [**IOCTL \_ SPB \_ 执行 \_ 序列**](https://msdn.microsoft.com/library/windows/hardware/hh450857) 请求，SPB 控制器驱动程序会将控制器硬件配置为在传输序列过程中在总线上生成合适的信号。 连接到总线的外围设备可能依赖于这些信号来检测原子总线操作何时进行。 SPB 控制器用于将传输序列作为原子总线操作来执行的一组硬件信号取决于总线类型。

对于 i2c 总线，控制器通过在总线上传输开始位来启动序列，并通过传输停止位结束序列。 在开始和停止位之间，将从设备传输到和传出的数据序列作为单个原子总线操作执行。 除顺序中的最后一个传输外，每个传输均后跟一个 I i2c 重启操作， (前面不是停止位) 的重复开始位。

对于 SPI 总线，控制器通过向目标设备断言芯片选择行来启动序列，并通过 deasserting 的芯片选择行结束序列。 通过在总线上传输数据时，通过使芯片选择行持续断言，传输将作为单个原子总线操作执行。

## <a name="an-example-ic-device"></a>例如，i2c 设备


I i2c 总线上的典型外围设备可能实现多个内部设备功能。 若要访问其中的某些函数，客户端可能会使用 [**IOCTL \_ SPB \_ 执行 \_ 序列**](https://msdn.microsoft.com/library/windows/hardware/hh450857) 请求。

例如，I i2c 外围设备可能包含以下两个内部寄存器：

-   一个 *函数地址寄存器* ，客户端将该地址注册为要访问的设备函数的内部地址。
-   一个 *数据寄存器* ，客户端通过该寄存器读取数据或将数据写入指定的函数地址。

在此示例中，I i2c 外围设备将开始位后写入设备的第一个字节解释为加载到函数地址寄存器中的函数地址。 序列结束之前，从设备传输到或从设备传输的任何附加字节)  (由设备视为数据，作为要通过数据寄存器传输的数据。

若要执行写操作，客户端将发送写入 ([**IRP \_ MJ \_ 写入**](../kernel/irp-mj-write.md)) 请求，在该请求中，写入缓冲区中的第一个字节是函数地址，而缓冲区中的剩余字节是要写入函数地址的数据。

从设备读取会更加复杂。 假定在此示例中，I i2c 设备支持 "快速读取" 功能，该功能会在总线上检测到停止位时，自动将函数地址寄存器重置为其默认值0。 利用此功能，客户端可以读取来自函数地址0的数据，无需先写入函数地址寄存器。 此功能可以提高设备读取操作的速度，尤其是在大多数读取来自函数地址0并且相对较短的情况下。

但是，若要从非零的函数地址读取数据块，客户端仍必须先向函数地址寄存器写入一个字节，然后才能从数据寄存器读取数据块。 客户端必须作为原子总线操作执行这些写入和读取传输，以防止总线控制器在写入到函数地址寄存器之后以及在从数据寄存器中读取数据后传输停止位。 否则，停止位将导致从函数地址0而不是非零函数地址读取数据。

以下列表描述了客户端发送到此示例中的 i2c 设备的 i/o 请求系列，以便对位于设备中非零函数地址的数据执行读修改写入操作：

1.  **IOCTL \_SPB \_ 执行 \_ 顺序** -执行 i/o 传输序列以便从设备读取数据。 此序列中的第一次传输是向函数地址寄存器写入字节的字节。 序列中的第二次传输是从所选函数地址读取一些字节。 这两个传输在总线上以原子方式执行。
2.  **IRP \_向设备 \_ 写入写入** 数据的数据。 此请求写入缓冲区中的第一个字节是写入函数地址寄存器的值。 缓冲区中的剩余字节是写入选定函数地址的数据。

可以改为使用其他请求模式来执行此读修改-写入操作。 例如，步骤2中的 **IRP \_ MJ \_ 写入** 请求可以替换为指定两个数据传输的 **IOCTL \_ SPB \_ 执行 \_ 序列** 请求，两者都是写入。 序列中的第一个传输会将一个字节加载到函数地址注册。 第二次传输会将数据字节写入所选的函数地址。 与步骤2中的 **IRP \_ MJ \_ 写入** 请求不同，此请求不要求客户端将函数地址字节和数据字节组合到同一个写入缓冲区。

若要对此设备中的函数地址0执行读修改写操作，可以使用简单的读取 ([**IRP \_ MJ \_ read**](../kernel/irp-mj-read.md)) 请求来替换前面列表的步骤1中的**IOCTL \_ SPB \_ 执行 \_ 顺序**请求。

 

