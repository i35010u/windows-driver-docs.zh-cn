---
title: 录制期间的流延迟
description: 录制期间的流延迟
ms.assetid: b9391b34-acd8-4434-b00c-48bbbc0b6647
ms.date: 04/20/2017
ms.localizationpriority: medium
ms.openlocfilehash: c85098ac0001f2a7581a6f6e9b6a64301ca62f2b
ms.sourcegitcommit: f500ea2fbfd3e849eb82ee67d011443bff3e2b4c
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 08/31/2020
ms.locfileid: "89210361"
---
# <a name="stream-latency-during-recording"></a>录制期间的流延迟


当音频记录流处于运行状态时，WaveRT 端口驱动程序的角色会很小。 如下图所示，在录制过程中，音频设备捕获音频数据并将其写入循环缓冲区。 然后，音频引擎从缓冲区读取此数据。 此活动不需要来自端口驱动程序的干预。 换句话说，音频数据直接在音频硬件与用户模式应用程序之间流动，无需任何内核模式软件组件接触。

在下图中，当流流过缓冲区时，记录和读取位置会持续从左到右进行。 当记录或读取位置到达缓冲区末尾时，它将环绕到缓冲区的开头。

![说明记录流的延迟的关系图](images/wavert-record.png)

前面的关系图将 *记录位置* 标识为音频设备当前正在记录的示例的缓冲位置， (通过模拟到数字转换器或 ADC) 从麦克风捕获。 请注意，记录位置是音频设备经过 FIFO 后写入示例的未来缓冲区位置。 *读取位置*是音频引擎读取下一个样本的缓冲区位置。

音频设备在 ADC 中捕获音频采样的时间中的延迟，直到客户端读取它时，记录和读取位置之间只需分离。 此隔离是在关系图) 中标记为 A 和 B (的以下延迟源的总和：

**延迟 A**：从 ADC 捕获数据后，音频设备将数据存储在硬件 FIFO 中，直到它可以将数据写入到循环缓冲区。

**延迟 B**：在音频设备将数据写入循环缓冲区后，数据将驻留在缓冲区中，直到客户端读取数据。

客户端不能控制延迟 A，这完全取决于硬件。 典型的 FIFO 可以存储来自 ADC 的大约64示例。 但是，客户端会控制滞后时间 B。使延迟 B 太大会将不必要的延迟引入系统，但在音频设备写入缓冲区之前，会使数据太小而无法提前读取数据。

尽管客户端可以设置计时器以定期激活其缓冲区读取线程，但此方法不会达到最小延迟。 为了进一步降低延迟，客户端可以将音频设备配置为在每次设备完成将新的捕获数据块写入缓冲区时生成硬件通知。 在这种情况下，客户端线程由硬件通知而不是计时器激活。

通过让音频设备定期通知音频引擎，客户端可以使延迟时间比此情况下可行。

通常，客户端 (音频引擎) 可以通过将 [**KSPROPERTY \_ RTAUDIO \_ HWLATENCY**](./ksproperty-rtaudio-hwlatency.md) 请求发送到 WaveRT 端口驱动程序来获取音频设备用于流式传输延迟的延迟摘要。

客户端确定记录和读取位置之间的分离量后，客户端会监视记录位置中的更改，以确定读取位置应滞后的程度。 在 Windows Server 2008 及更高版本的操作系统中，客户端发送 [**KSPROPERTY \_ 音频 \_ 位置**](./ksproperty-audio-position.md) 或 [**KSPROPERTY \_ RTAUDIO \_ POSITIONREGISTER**](./ksproperty-rtaudio-positionregister.md) 属性请求，以确定记录位置。 后一种请求方法更高效，因为它允许客户端直接读取记录位置，而不会转换为内核模式例程以获取信息。

 

